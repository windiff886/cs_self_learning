# 0.写在开头

在2024年暑假，我通过北京理工大学机器人队的夏招加入了视觉组。从2024年8月到2025年1月的半年时间里，我有幸在视觉组学习和成长。虽然我在这一过程中取得了一些进展，但大部分成果得益于团队中学长们的前期努力和指导。在这段时间里，我深刻认识到自己还有很多不足，也更加明确了未来需要努力的方向。

我参与的项目中，许多基础性工作和初步成果都是视觉组的学长们留下的，他们的工作为我的学习提供了很好的起点。在此基础上，我与队友们进行了合作，尝试改进和优化现有的算法和工具。尽管这些改进仍有许多需要完善的地方，但我从中获得了许多宝贵的经验，尤其是在团队合作、问题分析与解决方面。

作为一项具有挑战性的机器人竞赛，RoboMaster 提供了一个实践平台，让我有机会将学到的知识应用于实际场景(事实上,我深感在课堂上学习的东西太少,这促使我去不断地自主学习)。尽管在比赛准备过程中，我遇到了不少困难，但也正是在这些挑战中，我得到了很多锻炼。通过调试和优化，我逐步熟悉了 ROS2、OpenCV、Git 等工具，虽然过程中依然有很多技术问题没有完美解决，但这为我未来的学习打下了基础。

为了将这半年在视觉组的工作进行总结，我选择了将我的一些思考和成果以 Markdown 文件的形式记录(个人认为如果要上传到GitHub,Markdown比Word等文件更加方便)，并上传到我的[学习仓库](https://github.com/windiff886/cs_self_learning)中。这个仓库中记录了我的自学成果.

回顾这段时间的经历，虽然我在技术上还有很多需要提升的地方，但通过这次经历，我对机器人视觉领域有了更加深入的了解，也体会到了团队合作和实践的重要性。这段经历让我更加清楚地意识到自己的短板，并激励我在未来不断改进和进步。

# 1.一个更好的开发环境

“工欲善其事，必先利其器。”一个良好的开发环境对提升开发效率至关重要。对于机器人开发来说，最理想的系统莫过于 Linux Ubuntu，而在开发语言方面，个人认为 C/C++ 是最佳选择。尽管学校曾教授过 C++ 课程，但这门课程仅覆盖了最基础的 C++ 语法，未涉及 CMake、Makefile、优秀的 IDE/编辑器以及开发环境等关键工具和配置。这使得我们在自学的过程中遇到了不少困难和挫折。

为了帮助那些有志于加入视觉组的成员，特别是新加入的成员，能够更快速地搭建一个高效的开发环境，我们开发了一些工具和教程。希望通过这些工具和资源，能够减少大家在环境搭建上的时间投入，帮助他们专注于更有挑战性和创造性的开发工作。

## 1.1 一键部署环境

写一段与视觉相关的代码时，通常需要引用各种外部库。对于C++初学者而言，配置开发环境无疑是一个繁琐且不太舒适的过程。参考小鱼的一键部署环境指令：```wget http://fishros.com/install -O fishros && . fishros```，我们开发了一个专门的一键部署工具。只需克隆我们的仓库并在终端中运行```python3 install.py```，就能自动为你配置所需的开发环境。

我认为，这个项目的优势主要体现在以下几个方面：

+ 简化新手入门：自动化配置开发环境，特别是当初学者不熟悉编译和系统变量配置等复杂过程时，能够显著减少入门门槛。
+ 解决访问墙问题：我们的仓库托管在Gitee上，内含OpenCV、OpenVino等外部库的源码，避免了由于翻墙问题导致无法下载外部库的困扰（虽然翻墙已是基本操作，但能省则省）。
+ 版本统一：我们会在环境配置过程中指定所需的库版本，避免因库版本不一致而带来的兼容性问题。
+ 附加工具安装：自动安装一些实用工具，如SSH和远程连接工具NoMachine，进一步提升开发效率。

当然，项目也有一些不足，主要体现在编译过程中可能会遇到外部依赖错误或编译所需硬件资源过多导致程序崩溃等问题。不过，在我们的ROS2生态系统彻底成型之前，这个项目依然大有可为。

## 1.2 虚拟机

对于初学者，我们推荐通过虚拟机来使用Ubuntu。虚拟机（Virtual Machine，简称VM）是一种能够模拟物理计算机的虚拟化技术。通过在物理硬件上运行虚拟机管理程序（Hypervisor），可以在同一台物理机器上创建多个虚拟操作系统实例。每个虚拟机都拥有独立的操作系统、应用程序和硬件资源，从而实现资源的隔离和独立运行。

在我们制作的教程中，使用了VMware来安装虚拟机。尽管虚拟机技术带来了许多便利，但它也存在一些显著的缺点：

+ 性能开销：虚拟机依赖于宿主操作系统和虚拟化软件，因此会产生一定的性能损耗。尽管现代硬件支持虚拟化加速，虚拟机的性能仍通常低于原生操作系统，尤其是在需要大量计算资源的场景中。最简单的例子是，当你编译大型项目时，虚拟机可能会因资源消耗过大而崩溃。

+ 资源占用：每个虚拟机都需要一定的CPU、内存和存储资源。随着虚拟机数量的增加，宿主系统的资源消耗也会相应增加，可能导致系统负载过重，尤其是在硬件资源有限的情况下（为了应对这一问题，许多队员已经将自家电脑升级到了32GB内存）。

+ 硬件兼容性问题：某些虚拟化平台可能与特定硬件的兼容性较差，导致某些硬件功能（如GPU加速或外部设备支持）无法完全发挥作用。例如，如果你打算将摄像头连接到虚拟机中，可能会遇到兼容性问题。

+ 图形化界面较弱：由于虚拟机的机制，VMware的图形化界面体验较差。我们通常建议在不需要使用图形界面的情况下，通过Windows系统中的VSCode通过SSH连接虚拟机进行开发。

+ 翻墙问题令人头疼：如果你没有找到适用于Ubuntu的VPN工具，想要通过Windows中的VPN来为虚拟机翻墙将变得非常麻烦。

## 1.3 双系统

虽然双系统方案能够克服虚拟机的性能限制，且网络上有大量详细的安装教程可供参考，但基于实际使用经验，我不建议采用双系统作为首选方案。主要有以下两点考虑：

1. 系统稳定性：Ubuntu作为开源操作系统，虽然具有强大的功能，但在日常使用中可能会遇到一些系统崩溃或驱动兼容性问题。

2. 软件生态：相比Windows平台，Ubuntu的软件生态相对不够完善，许多常用软件缺乏Linux版本或其功能受限，这可能会影响日常办公和学习效率。

基于以上考虑，我们找到了两种更为可行的替代方案。

## 1.4 Docker

### 1.4.1 什么是Docker
Docker是一个开源的应用容器引擎，它让开发者可以：
- 将应用及其依赖打包到一个可移植的容器中
- 实现"一次构建，到处运行"
- 保证开发、测试和生产环境的一致性

### 1.4.2 核心概念
- **镜像(Image)**: 只读的模板，包含运行应用所需的所有内容
- **容器(Container)**: 镜像的运行实例，可以被启动、停止、删除
- **仓库(Repository)**: 集中存放镜像文件的场所

### 1.4.3 Docker的优势
- 轻量级：容器共享主机OS，启动快速
- 性能好：内存、cpu核数等都与电脑共享，能达到理论性能最优
- 一致性：消除"在我机器上能运行"的问题
- 隔离性：应用间互不影响
- 易于扩展：快速部署和更新

### 1.4.4 Docker的缺点

我们制作了一个Docker的镜像，打开即可完美运行我们的代码，但是Docker还有一些问题，例如缺少图形化界面的支持以及使用上不那么稳定。

## 1.5 WSL2

WSL2和Docker也是息息相关，个人认为WSL2胜在拥有更加详细完善的官方教程，也拥有许多别的功能例如图形化界面，同时WSL2与Windows系统完美兼容。我现在主要使用WSL2.

致命缺点：使用VPN并且开启镜像的网络模式的时候ROS2的通讯有问题

# 2.ROS2框架下的自瞄程序

开发环境的探索属于课余探索，真正的


# mix_detector

+ 从摄像头获取图像
+ 用YoloV8从图像中推理出装甲板（主要是找到4个点，颜色及装甲板id）
+ 找到四个点连成框，然后适当扩大，用传统视觉在扩大的框内识别灯条，并且与神经网络推理的结果进行匹配
  
# pos_manager

+ 已知装甲板的大小，已知装甲板上4个点在图像中的坐标，用pnp算出装甲板在相机坐标系的坐标
+ 从tf获取yaw，pitch，row，由于相机坐标系中心到世界坐标系中心的位移固定，可以算出装甲板在世界坐标系的坐标
+ 利用坐标和相机内参，相机畸变等参数，算出装甲板相对于我们的yaw值
  
# whole_filter

+ 类本身的私有变量last_best_targets代表着之前发现的id为i(i=0,1,2,...8)的一块装甲板(可为空)
+ 首先将所有装甲板中id相同的装甲板放到一起，id不同的分开
+ 对于这一帧发现的所有装甲板，将其与之前找到的装甲板匹配，找到id相同且距离最近的两块装甲板